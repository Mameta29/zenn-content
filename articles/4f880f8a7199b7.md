---
title: "JPYC決済の実装パターンを考える：オフチェーン決済IDとオンチェーンTxを紐付けるためには"
emoji: "💰"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["jpyc", "blockchain", "ethereum"]
published: true
---
## はじめに

JPYCは、USDCと同様に[EIP-2612 (permit)](https://eips.ethereum.org/EIPS/eip-2612)や[EIP-3009 (Authorization系)](https://eips.ethereum.org/EIPS/eip-3009)といった規格を実装しており、さまざまな決済機能があります。

しかし、これらの機能を実際の決済システム（ECサイト、POSレジ、サブスクリプション）に組み込む際の課題の1つとして、「**オフチェーンで管理される決済ID（例：`order_123`）と、ブロックチェーン上で実行されるトランザクションの紐付け方法**」という問題です。

この記事は、JPYC決済の導入を考えている開発者に向けて
「どの注文に対する支払いだったのか？」ということをブロックチェーン上で追えるようにするための具体的なパターンをいくつか解説します。

JPYCの機能だけで開発できるパターンは詳しく、そしてPermit2やAccount Abstraction(AA)、CREATE2など応用的な方法は紹介程度にサクッと説明していきます。

またJPYCの関数はこちらに全て解説しておりますので、参考されてみて下さい。

https://zenn.dev/mameta29/articles/4dcb803377b4ae

:::message
ここで述べる内容は私個人の考えで、所属先の公式見解ではありません。
また、決済の方法も最適なものというわけではなく、あくまでも私の考えであることはご理解ください。
:::

## JPYC決済の基礎：なぜ`transfer`では不十分か？

まず、基本となるERC20の関数と、それが決済において抱える課題を簡単に確認します。

### 1\. `transfer`: シンプルだが、情報がない

`transfer(to, amount)`は最も基本的な送金機能ですが、オンチェーンのデータには「誰から（`from`）」「誰に（`to`）」「いくら（`amount`）」という情報しか含まれません。

これだと、事業者が受け取った送金が「ECサイトのどの注文ID（`paymentId`）のものか」を特定できません（難しいです）。同じ金額の注文が同時に複数入った場合、区別が難しくなります。

### 2\. `approve` + `transferFrom`: 「決済コントラクト」をかませる

この問題を解決する標準的な方法が、`approve`（承認）と`transferFrom`の組み合わせです。

1.  **ユーザー**が、事業者の「決済ゲートウェイ・コントラクト」に対し、`approve`で送金を許可
2.  **決済ゲートウェイ・コントラクト**が、`transferFrom`を使ってユーザーのウォレットから事業者のウォレットへ資金を移動させる

この方法の最大の利点は、`transferFrom`を**カスタム関数でラップ（包む）**できることです。

```solidity
// 決済ゲートウェイ・コントラクトの例
contract PaymentGateway {
    IERC20 public jpyc;
    address public merchantWallet;

    event PaymentSettled(bytes32 indexed paymentId, address indexed customer, uint256 amount);

    // ユーザーがこの関数を呼び出す *paymentIdを引数に渡せる
    function executePayment(bytes32 paymentId, uint256 amount) external {
        // 1. ユーザー(msg.sender)からこのコントラクトへ資金を移動
        jpyc.transferFrom(msg.sender, merchantWallet, amount);
        
        // 2. ★ 決済IDを含めたイベントを発行 ★
        emit PaymentSettled(paymentId, msg.sender, amount);
    }
}
```

このように、`executePayment`のようなカスタム関数に`paymentId`を持たせて、**オンチェーンのイベントに`paymentId`を明示的に記録**できます。これが、決済ID紐付けの基本的な方法です。

![](/images/jpyc_approve.png =500x)
しかし、この方法ではユーザーは「`approve`（1回目）」と「`executePayment`（2回目）」の**2回のトランザクション**が必要になり、UXが悪いです。

これを解決するのが前述した、`permit`や`EIP-3009`です。


## 【主要パターン1】 `permit` + `transferFrom`：イベントで決済IDを刻む

これは、前述の`approve` + `transferFrom`の課題を、EIP-2612の`permit`を使って解決する最も標準的なパターンです。`approve`操作をガスレスの「オフチェーン署名」に置き換えます。

### コンセプト
1.  **ユーザー（オフチェーン）**:
    ECサイト上で、JPYCを決済ゲートウェイ・コントラクトに資産の移転を許可する`permit`署名をする。**ガス代はかからない**。
2.  **リレイヤー（オフチェーン）**:
    事業者のバックエンド（リレイヤー）が、この`permit`署名と、紐付けたい`paymentId`を受け取る。
3.  **ゲートウェイ（オンチェーン）**:
    リレイヤーが、`paymentId`と`permit`署名を引数にして、決済ゲートウェイ・コントラクトの`executePaymentWithPermit`(下記コード参照)のような関数を呼び出す（ガス代はリレイヤー負担）。
4.  **コントラクト内部の動作**:
    a. `jpyc.permit(...)`を呼び出し、署名を使ってガスレスで`approve`する
    b. `jpyc.transferFrom(...)`で、許可された資金をユーザーから事業者へ移転
    c. `emit PaymentSettled(paymentId, ...)`で、`paymentId`を含むイベントを発行👉**ブロックチェーン上に決済IDを記録できる**

### コードイメージ (Solidity)

```solidity
import "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC2612.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract PaymentGatewayWithPermit {
    IERC2612 public immutable jpyc;
    address public immutable merchantWallet;

    event PaymentSettled(bytes32 indexed paymentId, address indexed customer, uint256 amount);

    constructor(address jpycAddress, address merchant) {
        jpyc = IERC2612(jpycAddress);
        merchantWallet = merchant;
    }

    // リレイヤーがこの関数を叩く
    function executePaymentWithPermit(
        bytes32 paymentId, // オフチェーンの決済ID
        address customer,
        uint256 amount,
        // EIP-2612 permit 署名
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        // 1. 署名を検証し、Approveを実行
        jpyc.permit(customer, address(this), amount, deadline, v, r, s);

        // 2. 許可された資金をユーザーから事業者へ移動
        jpyc.transferFrom(customer, merchantWallet, amount);

        // 3. 決済IDをオンチェーンイベントとして記録
        emit PaymentSettled(paymentId, customer, amount);
    }
}
```

### メリット (Pros)

  * **監査性**: 自作したコントラクトから`paymentId`が明示的に`emit`されるため、後からトランザクション+決済IDを追えたり、インデックスが簡単にできる。
  * **柔軟性**: `executePaymentWithPermit`関数内で、手数料の計算、返金ロジックの追加、他のコントラクトの呼び出しなど、複雑なビジネスロジックなど、カスタマイズで実装可能。

### デメリット (Cons)

  * **コスト**: メリットの裏返しではあるが、コントラクトを独自にデプロイしなければならなかったり、そもそも資金を扱うコードなので監査が必要になったりする。
  * **信頼が必要**: ユーザーは、この（事業者が用意した）決済ゲートウェイ・コントラクトを信頼するしかない。もし悪意のあるコードである場合にはユーザーの資産が抜かれてしまう可能性がある。

-----

## 【主要パターン2】 EIP-3009 (`transferWithAuthorization`)：`nonce`を決済IDとして使う

これは、EIP-3009の`nonce`の仕様を活用し、**カスタムコントラクト無しで**決済IDを紐付ける、自分的におすすめなパターンです。

### コンセプト

EIP-3009の`transferWithAuthorization`関数は、リプレイ攻撃を防ぐために`bytes32 nonce`という引数を取ります。EIP-2612の`nonce`がインクリメント(連番)であるのに対し、EIP-3009の`nonce`は**任意の32バイト値**を指定できます。

:::message
この「任意の`bytes32 nonce`値」を「`paymentId`のハッシュ値」として利用するという発想です！
(これを思いついた時にはめちゃくちゃガッツポーズしました笑)
:::

1.  **バックエンド（オフチェーン）**:
    決済要求が発生した際、UUIDv4などでユニークな`paymentId`を生成する。
    `bytes32 nonce = keccak256(abi.encodePacked(paymentId));` のように、`paymentId`のハッシュ値を計算し、これを`nonce`とする。
    この`paymentId ↔ nonce`の対応をデータベースに保存します。
2.  **ユーザー（オフチェーン）**:
    `transferWithAuthorization`（または`receiveWithAuthorization`）のためのEIP-712署名を行います。この署名には、バックエンドが指定した`nonce`が含まれます。**ガス代は不要**
3.  **リレイヤー（オンチェーン）**:
    リレイヤーがユーザーの署名と`nonce`を使って、JPYCコントラクトの`transferWithAuthorization`を直接呼び出す（ガス代はリレイヤー負担）。
4.  **JPYCコントラクト（オンチェーン）**:
    送金が実行され、JPYCコントラクト自体が標準イベントである`AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce)`を発行する。👉**ブロックチェーン上にnonceとして決済IDを記録できる**

### オンチェーンとオフチェーン情報の紐付け

事業者のインデクサー（監視システム）は、JPYCコントラクトが発行する`AuthorizationUsed`イベントを監視します。

イベントで`nonce`（例: `0x...abcdef`) をキャッチできたら、データベースを検索し、「この`nonce`は、どの`paymentId`（例: `order_123`）に対応していたか」を逆引きして突合します。

:::message
`paymentId ↔ nonce`の対応をデータベースに保存するのではなく、そもそもの決済IDとしてnonceを使用して`paymentId = nonce`というのも場合によってはありかなとも思います。
:::

### メリット (Pros)

  * **コントラクト不要**: **追加のカスタムコントラクトをデプロイする必要がない**。JPYCトークンコントラクトの標準機能だけで完結するのは大きいメリット。
  * **シンプル＆低コスト**: **コントラクト不要**にも通じますが、システムがシンプルになり、デプロイや監査のコストがない。

### デメリット (Cons)

  * **突合の複雑さ**: 「誰に（`to`）」「いくら（`amount`）」という情報を知るには、**同じトランザクションハッシュ（`txHash`）内で発生した`Transfer`イベント**も併せて監視し、2つのイベントを突合させる必要がある。RPCの不具合などがあった場合はどうするかなど、考えるべき部分は多い。

はい、承知いたしました。
いただいたフィードバックを元に、「参考パターン」のセクションを修正・改善します。

---

## 【参考パターン1】 Permit2 + `witness`：署名に決済IDを入れ込む

ここからは、技術的にも難易度が段階が上がりますが、参考程度に上記以外のいくつかのパターンをご紹介します。

### フロー

Permit2は「規格」ではなく、Uniswapが各チェーンにデプロイした**単一のスマートコントラクト**です。EIP-2612 (`permit`) に未対応のトークンでも、署名ベースの承認移転を可能にします。

1.  **【初回のみ・オンチェーン】 ユーザー → Permit2**
    ユーザーは、**最初の一度だけ**、自分のJPYC（または他のトークン）を**Permit2コントラクト自体に対して**、オンチェーンで`approve`を実行します。（ガス代が必要です）
2.  **【決済ごと・オフチェーン】 ユーザー → 事業者**
    以降の決済では、ユーザーは`permitWitnessTransferFrom`のための「Permit2用の署名」をオフチェーンで行い、事業者に渡します。（**ユーザーのガス代は不要**です）
3.  **【決済ごと・オンチェーン】 事業者 → Permit2**
    事業者はその署名を受け取り、**ガス代を負担して**Permit2コントラクトの`permitWitnessTransferFrom`関数を呼び出します。

### `witness` とは？

Permit2の`permitWitnessTransferFrom`という特別な関数は、送金署名に「**追加の文脈（= `witness`）**」を暗号学的に含めることができます。

**コンセプト**:
`paymentId`のハッシュ値を、この`witness`データとして署名に含めます。

**オンチェーンとオフチェーン情報の紐付け**:
Permit2コントラクトは、署名を検証する際、「送金内容」だけでなく「`witness`（＝`paymentId`のハッシュ）」も一致しているか検証します。

これによって、「**この署名は、この`paymentId`の決済以外では絶対に使えない**」ということを暗号学的に保証できます。パターン1（`permit`と`transferFrom`のラッパー）では、`paymentId`は単なる関数の引数でしたが、Permit2+`witness`では、`paymentId`が署名そのものと結びくようになります。

### メリット (Pros)

* **セキュリティ**: 署名と決済IDが暗号学的に紐付くため、署名の使い回し（リプレイ攻撃）や文脈外で何かしら悪用しようとした時にも防止できます。
* **トークンの汎用性**: これはJPYCに限らず、EIP-2612未対応のトークンでも、同じPermit2のフローで決済システムを構築できます。

### デメリット (Cons)

* **複雑さ**: EIP-712の署名データ構造（`witnessTypeString`の定義など）が非常に複雑になり、フロントエンドでの署名生成の難易度は上がります。
* **外部依存**: UniswapのPermit2という外部コントラクトに依存します。
* **初回`approve`の手間**: ユーザーは最初に一度だけ、Permit2コントラクトへのオンチェーン`approve`（ガス代が発生）を実行する必要があります。

-----

## 【参考パターン2】 Account Abstraction (ERC-4337)：`userOpHash`で決済全体を追跡する

### これは何か？

Account Abstraction (AA) またはERC-4337は、ユーザーのウォレット自体をスマートコントラクト（**スマートコントラクトウォレット, SCW**）にする仕組みです。

* 従来のウォレット（EOA）では、ユーザーは「トランザクション（Tx）」に署名しました。
* SCWでは、ユーザーは「**ユーザーオペレーション（UserOperation, userOp）**」という「やりたいことの指示書」に署名します。
* この`userOp`を「バンドラー」と呼ばれるリレイヤーが拾い集め、ブロックチェーン上の「EntryPoint」という単一のコントラクトを通じて実行します。

### オンチェーンとオフチェーン情報の紐付け

この仕組みでは、**`userOpHash`** というハッシュ値が、オフチェーンの`paymentId`とオンチェーンの実行結果を紐付けるために機能します。

1.  **発行時（POSアプリ側）**:
    * 決済アプリが`userOp`（例：「私のウォレットから、A店のウォレットへ100JPYC送る」）を作る。
    * この`userOp`をバンドラーに送信する（`eth_sendUserOperation`）。
    * **このRPCの戻り値として得られる `userOpHash`**（一意のID）を取得する。
    * この時点で、**オフチェーンDBに `(paymentId, userOpHash)` を保存**し、ステータスを`Pending`にする。
2.  **確定時（インデクサー側）**:
    * バンドラーによって`userOp`が実行されると、EntryPointコントラトは`UserOperationEvent(bytes32 indexed userOpHash, ...)`というイベントを発行する。
    * インデクサーはこのイベントを監視して、**DBに保存した`userOpHash`**を見つけたら、対応する`paymentId`のステータスを`Settled`に更新する。

### メリット (Pros)

* **一貫して追跡できる**: `userOpHash`という**単一のID**で、オフチェーンでの発行リクエスト時からオンチェーンでの確定時まで、処理全体を一貫して追える。
* **AAのいろんな機能**: ユーザーのガス代肩代わり（Paymaster）、複数操作のバッチ処理、ソーシャルリカバリーなど、AAでできるさまざまなUXを決済に組み込める。

### デメリット (Cons)

* **インフラが必要**: ユーザーがSCW（ERC-4337準拠）を使っている必要がある。
* **エコシステムへの依存**: バンドラーやPaymasterといったAAインフラの安定稼働に依存します。（ちなみに、現状JPYCでガス代を直接支払えるようなPaymasterはまだないはずです）

## 【参考パターン3】 1決済1アドレス (CREATE2 Proxyパターン)

### アーキテクチャ

これは、1回の決済ごとに専用の送金先アドレスを**CREATE2によって事前計算**で生成し、ユーザーがそこに送金した後、コントラクトの「実体」をデプロイして資金を回収する方式です。

こちらのOpenZeppelinの記事を参考にしています

https://www.openzeppelin.com/news/getting-the-most-out-of-create2?utm_source=chatgpt.com

* **ロジックコントラクト (Logic Contract)**: 決済ロジック（資金回収、返金など）を持つ大元のコントラクト。
* **プロキシ (Proxy)**: ロジックコントラクトの呼び出しを中継する代理コントラクト。`creation_code`（生成コード）が常に同じである点が重要。
* **ファクトリー (Factory)**: `CREATE2`を使い、指定した`salt`でProxyのインスタンスをデプロイするためのコントラクト。

### オンチェーンとオフチェーン情報の紐付けフロー

1.  **【準備】**
    「ロジックコントラクト」と「ファクトリーコントラクト」を事前にデプロイしておきます。
2.  **【アドレスの事前計算】**
    オフチェーンで`paymentId`が発行されると、事業者は`paymentId`に紐づく`salt`（一意な値）を生成します。`CREATE2`の仕組み（`hash(factory_address, salt, proxy_creation_code)`）を使い、**決済専用の「送金先アドレス」をオフチェーンで事前計算**します。この「`paymentId` ↔ 決済専用アドレス」の対応をDBに保存します。
3.  **【ユーザー送金 (Counterfactual)】**
    ユーザーは、ステップ2で**事前計算された「送金先アドレス」**（まだ実体はデプロイされていない）宛に、JPYCを`transfer`します。
4.  **【入金の検知】**
    オフチェーンの監視システムがJPYCの`Transfer`イベントを監視します。入金先がDBに保存されている「送金先アドレス」のいずれかと一致した場合、対応する`paymentId`の決済が実行されたと特定します。
5.  **【コントラクトの実体化と資金回収】**
    事業者は「ファクトリー」を呼び出し、ステップ2で使った`salt`を指定して、該当のアドレスに**Proxyコントラクトの実体をデプロイ**します。デプロイ後、Proxyの**初期化関数（`initialize`）**を呼び出し、入金されたJPYCを事業者のウォレットへ回収します。

### メリット (Pros)

* **transfer関数で決済IDと紐付けできる**: `CREATE2`により「決済IDと1対1で紐づくアドレス」を事前に特定でき、ユーザーはシンプルな`transfer`を実行するだけで済む。

### デメリット (Cons)

* **ガス代**: 最終的に「Proxyデプロイ + 資金回収」のトランザクションが必要になり、L2であっても他のパターンに比べてガス代が高くなる。
* **複雑**: `CREATE2`のアドレス計算、ファクトリーパターンの管理、資金回収の実行管理など、システム全体の設計・運用がかなり複雑。

## 結論と推奨パターン

JPYC決済で現実世界(オフチェーン)の決済IDとオンチェーンTxを紐付ける方法を見てきました。どのパターンを選ぶかは、システムの要件と許容できる複雑さによります。

特に複雑な決済システムを必要としないのであれば個人的には【パターン2】EIP-3009の特に **`nonce`を`paymentId`ハッシュとして使う** というのが難しいこと考えず、独自でコントラクトをデプロイする必要もないのでいいよなぁと思います。もしコントラクトを自分で書いてそれをデプロイして実際に使用するとなれば監査も必要になります。なるべくコントラクトを書かなくてもよい実装がJPYCにはされているので、ぜひ決済システムの開発に活用されてみて下さい！

JPYCが色々な場面で使えるようになると、ブロックチェーンと現実世界との境界を意識することなく決済やRWAなどのやり取りが普通になり、何か中央集権的な存在に干渉されない、個々人がより自由な世の中になると信じています。